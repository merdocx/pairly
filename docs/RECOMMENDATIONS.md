# Рекомендации: оптимизация, безопасность, тесты

**Дата:** 28.01.2026  
**Версия проекта:** 0.3.0  
**Повторный анализ:** углублённый, с фокусом на производительность

---

## 1. Безопасность

### Сделано

- **Rate limiting** — включён `express-rate-limit`: auth 20 запросов/15 мин, API 120/мин. Ответ 429 в JSON.
- **Helmet** — включён с `crossOriginResourcePolicy: 'cross-origin'`, CSP отключён во избежание конфликтов со скриптами/стилями.
- **Валидация** — в movies роуте добавлена передача `AppError` в `next(e)`, чтобы 400 не превращались в 502.

### Критично (проверить в проде)

- **JWT_SECRET** — в коде есть fallback `'dev-secret-change-in-production'`. В проде обязательно задавать свой длинный случайный `JWT_SECRET` в `.env`.
- **CORS** — убедиться, что в проде `WEB_ORIGIN` не содержит `*`, перечислены только нужные домены.

### Желательно

- **Токен в localStorage** — при XSS токен можно украсть. Более безопасно: httpOnly cookie с secure в HTTPS (потребует изменений на бэкенде и фронте).
- **Валидация** — единообразно валидировать все query/params/body (Zod) и возвращать 400 при неверном формате. В watchlist `sort` ограничен двумя ветками в коде — SQL-инъекции нет.

---

## 2. Производительность (глубокий анализ)

### 2.1 Бэкенд: Watchlist и N+1

**Текущее поведение:**

- **GET /api/watchlist/me** — для каждой строки списка вызывается `getMovieDetail(movie_id)`. При 50 фильмах: до 50 обращений к Redis (или TMDB при промахе). Redis кэширует детали на 24 ч — при повторных запросах промахов меньше, но первый запрос после очистки кэша тяжёлый.
- **GET /api/watchlist/partner** — то же: N вызовов `getMovieDetail`.
- **GET /api/watchlist/intersections** — N вызовов `getMovieDetail` плюс **2N запросов к БД** (на каждый фильм два отдельных `SELECT rating` — по user и по partner). При 20 пересечениях: 20 обращений к TMDB/Redis + 40 запросов к PostgreSQL.

**Важное уточнение по intersections:**

SQL для пересечений уже исключает фильмы, у которых есть рейтинг у любого из пользователей:
`AND NOT EXISTS (SELECT 1 FROM ratings r WHERE r.user_id = $1 AND r.movie_id = w.movie_id) AND NOT EXISTS (... user_b ...)`.
Значит, для каждой строки результата рейтинги всегда отсутствуют. Текущие 2N запросов `SELECT rating` избыточны — они всегда возвращают пустой результат.

**Рекомендации:**

1. **Быстрый выигрыш: убрать 2N запросов в intersections**  
   В `GET /api/watchlist/intersections` не выполнять запросы рейтингов: для возвращаемых строк рейтингов нет по определению. Установить `my_rating`, `partner_rating`, `average_rating` в `null`. Это сразу убирает 2N round-trip к БД и упрощает код.

2. **Пересечения: батч-запрос рейтингов (если появятся «пересечения с рейтингами»)**  
   Если в будущем логика изменится и в пересечения попадут фильмы с рейтингами — вместо 2 запросов на каждый фильм делать один запрос по всем парам для user и один для partner:  
   `SELECT movie_id, rating FROM ratings WHERE user_id = $1 AND movie_id = ANY($2)` и то же для partnerId. В таблице `ratings` уже есть UNIQUE(user_id, movie_id), индекс по (user_id, movie_id) эффективен для такого батча.

3. **Опционально: денормализация списков**  
   Хранить в БД (или в отдельной таблице) `title`, `release_date`, `poster_path` при добавлении в watchlist (данные из TMDB на момент добавления). Тогда для списков не нужны вызовы getMovieDetail — только один запрос к БД. Минус: данные могут устареть; плюс: быстрый ответ и меньше нагрузка на TMDB/Redis.

4. **Параллелизм**  
   Сейчас используется `Promise.all(rows.map(...))` — параллельные вызовы к Redis/TMDB, что хорошо. Ограничивать параллелизм (например, p-limit) имеет смысл только при очень больших списках (100+), чтобы не перегружать TMDB.

### 2.2 Бэкенд: сжатие и кэш HTTP

- **Сжатие ответов** — JSON от API можно сжимать gzip/brotli. Подключить middleware `compression` в Express: `npm i compression`, затем `app.use(compression())` до маршрутов. Уменьшает размер ответа в 3–10 раз для списков и поиска.
- **Cache-Control** — для публичных данных можно добавить заголовки:
  - `GET /api/movies/search?q=...` — короткий кэш на клиенте или прокси (например, `private, max-age=60`) или не кэшировать из-за персонализации через куки/токен.
  - `GET /api/movies/:id` — при наличии CDN/прокси можно кэшировать по id (например, `public, max-age=3600`), т.к. детали фильма меняются редко.

### 2.3 Бэкенд: БД и Redis

- **Пул PostgreSQL** — `max: 20` в pool — разумно. Сверить с `max_connections` в PostgreSQL (обычно 100), чтобы сумма пулов всех приложений не превышала лимит.
- **Redis** — клиент создаётся один раз (singleton) — хорошо. При падении Redis все запросы к TMDB пойдут напрямую; при необходимости добавить fallback (без кэша) или быстрый fail.
- **getConfiguration()** — вызывается в каждом обработчике watchlist (me, partner, intersections); результат кэшируется в Redis на 7 дней — дополнительных запросов к TMDB не создаёт.

### 2.4 Фронтенд

- **next/image** — постеры переведены на `PosterImage` с next/image, домен `image.tmdb.org` в `remotePatterns` — хорошо для LCP и форматов.
- **Кэш вкладок** — списки (Мое / Партнера / Общее) не размонтируются при переключении вкладок — данные сохраняются, повторный запрос не уходит. Реализовано.
- **Размер бандла** — First Load JS ~88–103 kB — приемлемо. При росте — динамический импорт тяжёлых страниц (например, карточка фильма).
- **Дедупликация запросов** — при одновременном открытии нескольких экранов один и тот же путь (например, `/api/watchlist/me`) может вызываться дважды. Опционально: общий слой (SWR/React Query) с кэшем по ключу запроса.

### 2.5 Сводка по производительности

| Узкое место | Влияние | Рекомендация | Приоритет |
|-------------|---------|--------------|-----------|
| Intersections: 2N запросов рейтингов к БД | Высокое при N > 10 | Убрать запросы (рейтинги по логике всегда null) | Высокий |
| Watchlist: N вызовов getMovieDetail | Среднее (Redis смягчает) | Опционально: денормализация title/poster в БД | Средний |
| Нет gzip для JSON | Среднее (трафик) | Middleware `compression` | Средний |
| Нет Cache-Control для movies | Низкое | Заголовки для /api/movies/:id (опционально) | Низкий |

---

## 3. Покрытие тестами

### Сделано

- **Backend:**  
  - `health.test.ts` — GET /api/health  
  - `auth.validation.test.ts` — валидация register/login (400)  
  - `auth.401.test.ts` — 401 без токена и с неверным токеном для /api/pairs, /api/watchlist/me (GET/POST)  
  - `movies.test.ts` — поиск без q (пустой результат), некорректный id (400)  
  - `errorHandler.test.ts` — обработка ошибок  
  - В роуте movies: передача `AppError` в next(e), чтобы 400 не превращался в 502  

- **Web:**  
  - `api.test.ts` — getApiUrl, getErrorMessage  

- **CI (GitHub Actions):** в workflow запускаются `npm run test` для backend и web без БД/Redis; тесты unit/интеграционные без внешних сервисов проходят.

### Остаётся (рекомендации)

1. **Backend (при наличии тестовой БД в CI)**  
   Успешный сценарий: register → login → токен в заголовке.  
   Пары: создание пары, присоединение по коду, выход; 404 при отсутствии пары для partner/intersections.  
   Watchlist: добавление/удаление/оценка; проверка изоляции данных пользователя.

2. **Backend без БД**  
   Мокировать pool (или использовать in-memory SQLite для тестов) для интеграционных тестов пар и watchlist.

3. **Web**  
   Юнит-тесты утилит и хуков.  
   Опционально: компоненты (React Testing Library), E2E (Playwright/Cypress).

4. **CI**  
   Сейчас тесты backend не требуют БД (health, validation, 401, movies без TMDB). Для тестов с БД — сервис PostgreSQL в GitHub Actions и переменные DATABASE_URL, JWT_SECRET.

---

## 4. Краткий чек-лист

| Область | Действие | Статус |
|---------|----------|--------|
| Безопасность | Rate limit, helmet, JWT_SECRET и CORS в проде | ✅ Rate limit и helmet сделаны; проверить секреты и CORS в проде |
| Оптимизация | next/image, кэш вкладок | ✅ Сделано |
| Производительность | Убрать 2N запросов в intersections, compression, опционально денормализация | ✅ Убраны 2N в intersections, добавлен compression и Cache-Control для /api/movies/:id |
| Тесты backend | 401, movies (формат, invalid id) | ✅ Сделано; остаётся: pairs, watchlist, auth success (при тестовой БД) |
| Тесты frontend | Утилиты, при необходимости компоненты и E2E | Остаётся |
| Мониторинг | Логирование ошибок, метрики, медленные запросы к БД | ✅ Логирование в errorHandler (timestamp + stack для 500) |

---

## 5. Новые рекомендации (по результатам повторного анализа)

1. ~~**Убрать 2N запросов в GET /api/watchlist/intersections**~~ **Сделано.**  
   В intersections рейтинги не запрашиваются; в ответе всегда `my_rating`, `partner_rating`, `average_rating` = `null`.

2. ~~**Добавить middleware `compression`**~~ **Сделано.**  
   В Express подключён `compression()` — ответы JSON сжимаются gzip. Для GET /api/movies/:id добавлен заголовок `Cache-Control: public, max-age=3600`.

3. **Опционально:** в таблицу watchlist (или кэш) при добавлении фильма сохранять title, release_date, poster_path из TMDB, чтобы списки отдавать без N вызовов getMovieDetail; обновление — по необходимости или TTL.

4. **Проверить в проде:** `max` в pg.Pool не превышает доступный запас `max_connections` в PostgreSQL с учётом других приложений.

5. ~~**Логирование**~~ **Сделано.** В errorHandler для не-AppError логируются timestamp и stack (или message) через `console.error`.

6. **Индексы БД:** в `schema.sql` уже есть `idx_ratings_user`, `idx_ratings_movie` и UNIQUE(user_id, movie_id) в ratings — для батч-запросов вида `WHERE user_id = $1 AND movie_id = ANY($2)` этого достаточно.
