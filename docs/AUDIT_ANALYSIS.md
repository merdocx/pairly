# Аудит проекта Pairly: ошибки, дизайн, оптимизация, безопасность

**Дата:** 30.01.2026  
**Версия проекта:** 0.4.x  

---

## 1. Ошибки и баги

### 1.1 Backend

- **watchlist.ts:** используется тип `Request` в функции `uid(req: Request & { user: JwtPayload })`, но `Request` не импортирован из `express`. TypeScript может подхватывать глобальный тип; для ясности лучше добавить `import type { Request } from 'express'`.
- **pairs.ts:** в ответе `GET /` возвращается `partner: { email, name }`, но тип на фронте ожидает `partner: { id, email, name }`. Проверить контракт API и при необходимости добавить `id` в ответ.

### 1.2 Frontend

- **search/page.tsx:** ESLint предупреждение — `useEffect` для сортировки результатов зависит от `data`, но внутри используется `watchlistItems`. При изменении `watchlistItems` (например, после добавления фильма в список) сортировка не пересчитывается. Либо добавить `watchlistItems` в массив зависимостей (с риском лишних пересортировок), либо явно подавить предупреждение с комментарием, если текущее поведение («сортировка только при новом поиске») желательно.
- **Обработка ошибок:** во многих местах используется `alert(e instanceof Error ? e.message : 'Ошибка')`. Сообщения от API попадают пользователю в сыром виде; при 500 или сетевых ошибках лучше показывать дружелюбный текст (как в `getErrorMessage`), а не технический.

---

## 2. Дизайн и UX

### 2.1 Консистентность

- **Единый способ показа ошибок:** часть страниц (login, register) выводят ошибки под формой (`error-text`), в списках и модалках часто используется `alert()`. Имеет смысл унифицировать: тосты или inline-сообщения вместо `alert` для действий «добавить в список», «оценка», «удалить» и т.д.
- **Подтверждения:** «Выйти из пары» через `confirm()`. Для единообразия можно заменить на модалку в стиле приложения (как модалка «Добавить пару»).

### 2.2 Доступность (a11y)

- Модалки используют `role="dialog"`, `aria-modal="true"`, `aria-labelledby` — хорошо.
- Нет явной блокировки фокуса внутри модалки (focus trap) и возврата фокуса после закрытия — при навигации с клавиатуры фокус может уходить «за» модалку. Рекомендация: при открытии модалки фокусировать первый интерактивный элемент и по Esc закрывать (частично уже есть через overlay click).
- Кнопки без текста (только иконки, например «Удалить» с иконкой) имеют `aria-hidden` на SVG; у кнопки есть видимый текст — ок. Проверить, что у всех интерактивных иконок есть `aria-label` там, где текста нет.

### 2.3 Адаптивность

- Строка поиска и модалки настроены под «чуть уже экрана»; контейнеры с `max-width: 560px` / `400px` — поведение на очень узких экранах (< 320px) стоит проверить вручную.
- Нижнее меню и отступы с `env(safe-area-inset-bottom)` учтены — хорошо для устройств с вырезом.

---

## 3. Оптимизация

### 3.1 Backend

- **Watchlist GET /me, /partner, /intersections:** для каждой позиции при отсутствии денормализованных данных вызывается `getDetail()` (Redis/TMDB). Уже есть кэш и денормализация в watchlist; при росте числа пользователей можно ограничить параллелизм (например, p-limit с concurrency 5–10), чтобы не создавать пики нагрузки на TMDB.
- **TMDB:** при отсутствии `TMDB_API_KEY` запросы падают; в коде есть fallback `''`. Имеет смысл при старте в production проверять наличие ключа и логировать предупреждение, если его нет.
- **Пул БД:** используется один пул (pool); при высокой нагрузке проверить лимиты `max` и таймауты.

### 3.2 Frontend

- **Дублирование компонентов:** иконки (CheckIcon, CalendarIconSmall, ClockIconSmall и т.д.) объявлены и в `page.tsx`, и в `search/page.tsx`. Вынести в общий файл (например, `components/Icons.tsx`) и импортировать оттуда — меньше бандл и проще поддержка.
- **Поиск:** debounce 400 ms уже есть; при очень длинном вводе можно отменять предыдущий запрос (AbortController), чтобы не обрабатывать устаревшие ответы.
- **Модалки:** рендер через `createPortal(..., document.body)` и условный рендер по state — ок. При большом количестве модалок можно рассмотреть единый слой модалок (context + один портал).

### 3.3 Сеть и кэш

- **Next.js:** API проксируется через `rewrites` на backend; для production убедиться, что `NEXT_PUBLIC_API_URL` не указывает на localhost, если фронт и бэк на разных хостах.
- **Картинки:** используются `remotePatterns` для `image.tmdb.org`; Next/Image даёт оптимизацию форматов и размеров — хорошо.

---

## 4. Безопасность

### 4.1 Уже хорошо

- **Аутентификация:** JWT в httpOnly cookie (`pairly_token`) + опционально Authorization header; пароли через bcrypt; валидация (Zod) на регистрации и логине.
- **Rate limiting:** отдельные лимиты для auth (20/15 мин) и API (120/мин); `trust proxy: 1` для учёта реального IP за Nginx.
- **Helmet:** включён; CSP отключён (чтобы не ломать скрипты/стили) — при необходимости можно включить с осторожной политикой.
- **SQL:** везде параметризованные запросы (`$1`, `$2` и т.д.) — риска SQL-инъекций нет.
- **CORS:** проверка `WEB_ORIGIN`; в production выводится предупреждение при `*` или пустом origin.
- **Старт в production:** проверка `JWT_SECRET` и `WEB_ORIGIN` в `index.ts` — хорошо.

### 4.2 Рекомендации

- **JWT_SECRET:** в production обязательно задавать свой длинный случайный секрет (например, `openssl rand -base64 32`). Fallback `'dev-secret-change-in-production'` не должен использоваться в проде (предупреждение уже есть).
- **Токен в localStorage:** фронт дополнительно пишет токен в `localStorage` при login/register и читает в `api.ts` для заголовка Authorization. Это дублирует cookie; при XSS злоумышленник может украсть токен из localStorage. Имеет смысл по возможности опираться только на httpOnly cookie (бэкенд уже отдаёт cookie; проверить, что все запросы к API идут с `credentials: 'include'` и что без localStorage приложение корректно работает после перезагрузки).
- **Содержимое ошибок:** в ответах API не отдавать стек и внутренние детали; в `errorHandler` уже возвращается только `{ error: message }` и код — ок. Логирование стека в консоль сервера оставить как есть.
- **CSP:** если позже включите Content-Security-Policy, нужно будет разрешить домены скриптов, стилей и TMDB images; начать с report-only режима.

---

## 5. Сводка рекомендаций

### Высокий приоритет ✅

1. **Production:** задать уникальный `JWT_SECRET` и корректный `WEB_ORIGIN` в `.env`. _(Проверка при старте уже есть в index.ts.)_
2. **Frontend — ошибки:** ✅ Реализовано: тост (`ToastProvider` + `useToast()`), все `alert()` заменены на `showToast(getErrorMessage(e))`.
3. **Search page:** ✅ Добавлен комментарий `eslint-disable-next-line` с пояснением по зависимостям `useEffect`.

### Средний приоритет ✅

4. **Иконки:** ✅ Вынесены в `components/Icons.tsx` (CheckIcon, CalendarIconSmall, ClockIconSmall, CalendarIcon, ClockIcon).
5. **Модалки:** ✅ Закрытие по Esc добавлено в хук `useModalAnimation`.
6. **Backend:** ✅ Импорт `Request` добавлен в `watchlist.ts` и `pairs.ts`; контракт партнёра (id) уже был в ответе pairs.

### Низкий приоритет ✅

7. **Подтверждения:** ✅ Модалка «Выйти из пары?» вместо `confirm()` на странице профиля.
8. **TMDB:** ✅ При старте в production проверяется `TMDB_API_KEY` в `index.ts` (предупреждение в лог).
9. **p-limit:** ✅ В watchlist используется `p-limit` (concurrency 10) для вызовов TMDB getDetail.

### Дополнительно выполнено

- **Поиск:** AbortController для отмены предыдущего запроса при новом вводе (search/page.tsx).

---

## 6. Что уже в порядке

- Нет использования `dangerouslySetInnerHTML` / `eval` — риск XSS снижен.
- Валидация входных данных (Zod) на критичных маршрутах.
- Структура БД с индексами и ограничениями; миграции есть.
- Тесты (backend и web) и CI (GitHub Actions).
- Документация по деплою и рекомендациям в `docs/`.
- Анимации модалок и переходы между страницами реализованы аккуратно (CSS + хук).

Этот документ можно использовать как чек-лист для следующих итераций разработки и код-ревью.
